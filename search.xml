<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Springboot_JPA]]></title>
    <url>%2F2019%2F06%2F19%2FSpringboot-JAP%2F</url>
    <content type="text"><![CDATA[什么是JPA JPA是Java Persistence API的简称，中文名Java持久层API，是Sun官方提出的Java持久化规范，其设计目标主要是为了简化现有的持久化开发工作和整合ORM技术。JPA使用XML文件或注解（JDK 5.0或更高版本）来描述对象-关联表的映射关系，能够将运行期的实体对象持久化到数据库，它为Java开发人员提供了一种ORM工具来管理Java应用中的关系数据。 简单地说，JPA就是为POJO（Plain Ordinary Java Object）提供持久化的标准规范，即将Java的普通对象通过对象关系映射（Object-Relational Mapping，ORM）持久化到数据库中。由于JPA是在充分吸收了现有Hibernate，TopLink，JDO等ORM框架的基础上发展而来的，因而具有易于使用、伸缩性强等优点。 Spring Data JPA 是 Spring 基于 Spring Data 框架、在JPA 规范的基础上开发的一个框架，使用 Spring Data JPA 可以极大地简化JPA 的写法，可以在几乎不用写实现的情况下实现对数据库的访问和操作，除了CRUD外，还包括分页和排序等一些常用的功能。 JPA常用注解12345678910111213141516171819202122232425262728293031323334@Entity 作用：指定当前类是实体类。@Table 作用：指定实体类和表之间的对应关系。 属性： name：指定数据库表的名称@Id 作用：指定当前字段是主键。@GeneratedValue 作用：指定主键的生成方式。。 属性： strategy ：指定主键生成策略。 JPA提供的四种标准用法为TABLE,SEQUENCE,IDENTITY,AUTO。 IDENTITY:主键由数据库自动生成（主要是自动增长型） @GeneratedValue(strategy = GenerationType.IDENTITY) SEQUENCE：根据底层数据库的序列来生成主键，条件是数据库支持序列。 @GeneratedValue(strategy = GenerationType.SEQUENCE) AUTO：主键由程序控制(建议使用) @GeneratedValue(strategy = GenerationType.AUTO) TABLE：使用一个特定的数据库表格来保存主键 @GeneratedValue(strategy = GenerationType.TABLE) @Column 作用：指定实体类属性和数据库表之间的对应关系 属性： name：指定数据库表的列名称。 unique：是否唯一 nullable：是否可以为空 inserttable：是否可以插入 updateable：是否可以更新 columnDefinition: 定义建表时创建此列的DDL secondaryTable: 从表名。如果此列不建在主表上（默认建在主表），该属性定义该列所在从表的名字搭建开发环境[重点] Springboot整合JPA，druid引入jar包1234567891011121314151617181920212223&lt;!--jpa包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- mysql驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt;&lt;!-- alibaba druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.29&lt;/version&gt;&lt;/dependency&gt;&lt;!-- lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 配置application.properties文件123456789101112131415161718192021spring.datasource.url=jdbc:mysql://localhost:3306/guns?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.type: com.alibaba.druid.pool.DruidDataSourcespring.datasource.filters:statspring.datasource.maxActive: 20spring.datasource.initialSize: 1spring.datasource.maxWait: 60000spring.datasource.minIdle: 1spring.datasource.timeBetweenEvictionRunsMillis: 60000spring.datasource.minEvictableIdleTimeMillis: 300000spring.datasource.validationQuery: select 'x'spring.datasource.testWhileIdle: truespring.datasource.testOnBorrow: falsespring.datasource.testOnReturn: falsespring.datasource.poolPreparedStatements: truespring.datasource.maxOpenPreparedStatements: 20spring.jpa.properties.hibernate.hbm2ddl.auto=updatespring.jpa.show-sql=true 配置config类12345678910111213141516171819202122232425262728293031323334353637383940package com.example.springbootjpa.config;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class DriudConfig &#123; @Bean public ServletRegistrationBean statViewServlet() &#123; // 创建servlet注册实体 ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); // 设置ip白名单 servletRegistrationBean.addInitParameter("allow", "127.0.0.1"); // 设置ip黑名单,如果allow与deny共同存在时,deny优先于allow servletRegistrationBean.addInitParameter("deny", "192.168.0.1"); // 设置控制台管理用户 servletRegistrationBean.addInitParameter("loginUsername", "admin"); servletRegistrationBean.addInitParameter("loginPassword", "123456"); // 是否可以重置数据 servletRegistrationBean.addInitParameter("resetEnable", "false"); return servletRegistrationBean; &#125; @Bean public FilterRegistrationBean statFilter() &#123; // 创建过滤器 FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new WebStatFilter()); // 设置过滤器过滤路径 filterRegistrationBean.addUrlPatterns("/*"); // 忽略过滤的形式 filterRegistrationBean.addInitParameter("exclusions", "*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*"); return filterRegistrationBean; &#125;&#125; 编写实体类 表结构 123456789101112131415161718192021CREATE TABLE `sys_user` ( `USER_ID` bigint(20) NOT NULL COMMENT '主键id', `AVATAR` varchar(255) DEFAULT NULL COMMENT '头像', `ACCOUNT` varchar(45) DEFAULT NULL COMMENT '账号', `PASSWORD` varchar(45) DEFAULT NULL COMMENT '密码', `SALT` varchar(45) DEFAULT NULL COMMENT 'md5密码盐', `NAME` varchar(45) DEFAULT NULL COMMENT '名字', `BIRTHDAY` datetime DEFAULT NULL COMMENT '生日', `SEX` varchar(32) DEFAULT NULL COMMENT '性别(字典)', `EMAIL` varchar(45) DEFAULT NULL COMMENT '电子邮件', `PHONE` varchar(45) DEFAULT NULL COMMENT '电话', `ROLE_ID` varchar(255) DEFAULT NULL COMMENT '角色id(多个逗号隔开)', `DEPT_ID` bigint(20) DEFAULT NULL COMMENT '部门id(多个逗号隔开)', `STATUS` varchar(32) DEFAULT NULL COMMENT '状态(字典)', `CREATE_TIME` datetime DEFAULT NULL COMMENT '创建时间', `CREATE_USER` bigint(20) DEFAULT NULL COMMENT '创建人', `UPDATE_TIME` datetime DEFAULT NULL COMMENT '更新时间', `UPDATE_USER` bigint(20) DEFAULT NULL COMMENT '更新人', `VERSION` int(11) DEFAULT NULL COMMENT '乐观锁', PRIMARY KEY (`USER_ID`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='管理员表'; 实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.example.springbootjpa.entity;import lombok.Data;import javax.persistence.*;import java.io.Serializable;@Data //lombok的注解，作用自动生成get/set方法 （需要idea下载对应的插件）@Entity //指定这个是表的实体类@Table(name = "sys_user") //该实体类对应的表名public class SysUser implements Serializable &#123; @Id //指定这个是主键 @Column(name = "USER_ID") //对应的数据库字段名 @GeneratedValue(strategy=GenerationType.AUTO) //主键生成的策略，建议用AUTO,自动采用合适的策略 private Long userId; @Column(name = "AVATAR") private String avatar; @Column(name = "ACCOUNT") private String account; @Column(name = "PASSWORD") private String password; @Column(name = "SALT") private String salt; @Column(name = "NAME") private String name; @Column(name = "BIRTHDAY") private java.util.Date birthday; @Column(name = "SEX") private String sex; @Column(name = "EMAIL") private String email; @Column(name = "PHONE") private String phone; @Column(name = "ROLE_ID") private String roleId; @Column(name = "DEPT_ID") private Long deptId; @Column(name = "STATUS") private String status; @Column(name = "CREATE_TIME") private java.util.Date createTime; @Column(name = "CREATE_USER") private Long createUser; @Column(name = "UPDATE_TIME") private java.util.Date updateTime; @Column(name = "UPDATE_USER") private Long updateUser; @Column(name = "VERSION") private Long version;&#125; 利用idea自带的生成实体类功能 选择Database标签页 选择对应的数据库类型 配置账号密码数据库 如果无法连上数据库，请检测账号，密码，数据库名是否正确，或者更换数据库驱动版本 (多数都是数据库驱动原因) 成功连上的情况 操作流程 打开Generate POJOs.groovy 修改Generate POJOs.groovy模板(根据自身需求修改) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import com.intellij.database.model.DasTableimport com.intellij.database.model.ObjectKindimport com.intellij.database.util.Caseimport com.intellij.database.util.DasUtil/* * Available context bindings: * SELECTION Iterable&lt;DasObject&gt; * PROJECT project * FILES files helper *///修改为你的实体类的包名packageName = "com.example.springbootjpa.entity;"typeMapping = [ (~/(?i)int/) : "Long", (~/(?i)float|double|decimal|real/): "Double", (~/(?i)bool|boolean/) : "Boolean", (~/(?i)datetime|timestamp/) : "java.util.Date", (~/(?i)date/) : "java.sql.Date", (~/(?i)time/) : "java.sql.Time", (~/(?i)/) : "String"]FILES.chooseDirectoryAndSave("Choose directory", "Choose where to store generated files") &#123; dir -&gt; SELECTION.filter &#123; it instanceof DasTable &amp;&amp; it.getKind() == ObjectKind.TABLE &#125;.each &#123; generate(it, dir) &#125;&#125;def generate(table, dir) &#123; def className = javaName(table.getName(), true) def fields = calcFields(table) new File(dir, className + ".java").withPrintWriter &#123; out -&gt; generate(out, table, className, fields) &#125;&#125;def generate(out, table, className, fields) &#123; def tableName = table.getName() out.println "package $packageName" out.println "" out.println "import lombok.Data;" out.println "" out.println "import javax.persistence.*;" out.println "import java.io.Serializable;" out.println "" out.println "@Data" out.println "@Entity" out.println "@Table(name = \"$tableName\")" out.println "public class $className implements Serializable &#123;" out.println "" // 判断自增 if ((tableName + "_id").equalsIgnoreCase(fields[0].colum) || "id".equalsIgnoreCase(fields[0].colum)) &#123; out.println "\t@Id" out.println "\t@GeneratedValue(strategy=GenerationType.AUTO)" &#125; fields.each() &#123; if (it.annos != "") out.println " $&#123;it.annos&#125;" if (it.colum != it.name) &#123; out.println "\t@Column(name = \"$&#123;it.colum&#125;\")" &#125; out.println "\tprivate $&#123;it.type&#125; $&#123;it.name&#125;;" out.println "" &#125; out.println "&#125;"&#125;def calcFields(table) &#123; DasUtil.getColumns(table).reduce([]) &#123; fields, col -&gt; def spec = Case.LOWER.apply(col.getDataType().getSpecification()) def typeStr = typeMapping.find &#123; p, t -&gt; p.matcher(spec).find() &#125;.value fields += [[ name : javaName(col.getName(), false), colum: col.getName(), type : typeStr, annos: ""]] &#125;&#125;def javaName(str, capitalize) &#123; def s = str.split(/(?&lt;=[^\p&#123;IsLetter&#125;])/).collect &#123; Case.LOWER.apply(it).capitalize() &#125; .join("").replaceAll(/[^\p&#123;javaJavaIdentifierPart&#125;]/, "_").replaceAll(/_/, "") capitalize || s.length() == 1 ? s : Case.LOWER.apply(s[0]) + s[1..-1]&#125; 生成实体类java文件.png 根据实际情况进行修改实体类 问题：实体类主键字段没有@Id，@GeneratedValue(strategy=GenerationType.AUTO)注解 答：解决方法：修改Generate POJOs.groovy模板的逻辑，或者实体类中手动添加对应的注解 如需修改Generate POJOs.groovy模板，主要逻辑就是下面代码： 12345// 判断自增if ((tableName + "_id").equalsIgnoreCase(fields[0].colum) || "id".equalsIgnoreCase(fields[0].colum)) &#123; out.println "\t@Id" out.println "\t@GeneratedValue(strategy=GenerationType.AUTO)"&#125; 使用jpa开发 声明一个接口继承JpaRepository&lt;T,ID&gt;,JpaSpecificationExecutor&lt;T&gt; 示例： 12345@Repository //标识public interface MyUserDao extends JpaRepository&lt;SysUser,Long&gt;, JpaSpecificationExecutor&lt;SysUser&gt; &#123; //T =&gt; SysUser：对应的实体类类型 //ID =&gt; Long：实体类的主键类型&#125; 查询方法findById(Long id)[根据id查找]123456789101112@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringbootJpaApplicationTests &#123; @Autowired private MyUserDao dao; @Test public void contextLoads() &#123; //后面的例子都省略一些代码，只保留主要代码 Optional&lt;SysUser&gt; userOptional = dao.findById(5L); SysUser sysUser = userOptional.get(); &#125;&#125; findAll()[查询全部]1List&lt;SysUser&gt; allSysUser = dao.findAll(); findAll(Sort sort)[设置排序]1234Sort userIdSort = Sort.by("userId").descending();Sort versionSort = Sort.by("version").ascending();Sort andSort = userIdSort.and(versionSort);List&lt;SysUser&gt; userId = dao.findAll(andSort); 123456789101112131415/*注意order by排序order by sysuser0_.user_id desc, sysuser0_.version asc*/ select sysuser0_.user_id as user_id1_1_, -- 省略一部分sql sysuser0_.version as version18_1_ from sys_user sysuser0_ order by sysuser0_.user_id desc, sysuser0_.version asc findAll(Example example)Example讲解 Probe: 含有对应字段的实例对象。 ExampleMatcher：携带有关如何匹配特定字段的详细信息，相当于匹配条件。 Example：由Probe和ExampleMatcher组成，用于查询。 简单字段查询 java代码 12345SysUser sysUser = new SysUser();sysUser.setPhone("567"); sysUser.setName("wzk");Example&lt;SysUser&gt; sysUserExample = Example.of(sysUser);List&lt;SysUser&gt; all = dao.findAll(sysUserExample); sql 12345678910111213 select sysuser0_.user_id as user_id1_1_, -- 省略一部分sql sysuser0_.version as version18_1_ from sys_user sysuser0_ where sysuser0_.phone=? and sysuser0_.name=?/*binding parameter [1] as [VARCHAR] - [567]binding parameter [2] as [VARCHAR] - [wzk]*/ 根据ExampleMatcher匹配查找 java代码 123456789//new一个实体类SysUser sysUser = new SysUser();sysUser.setName("wzk");sysUser.setPhone("5");ExampleMatcher nameMatcher = ExampleMatcher.matching().withMatcher("name", ExampleMatcher.GenericPropertyMatchers.exact());ExampleMatcher phoneMatcher = nameMatcher.withMatcher("phone", ExampleMatcher.GenericPropertyMatchers.startsWith());Example&lt;SysUser&gt; sysUserExample = Example.of(sysUser,phoneMatcher);ExampleMatcher matcher = sysUserExample.getMatcher();List&lt;SysUser&gt; all = dao.findAll(sysUserExample); 作用如下图 ExampleMatcher局限性1234ExampleMatcher matchingAll = ExampleMatcher.matchingAll();ExampleMatcher matchingAny = ExampleMatcher.matchingAny();//要么选择匹配所有条件 sql：where 参数1 = ？AND 参数2 = ？ AND 参数3 = ？ AND 。。。。。。//要么选择匹配符合 sql：where 参数1 = ？OR 参数2 = ？ OR 参数3 = ？ OR 。。。。。。 Specification讲解 好处能随意拼接and，or条件，不像ExampleMatcher不灵活！ java代码 1234567891011121314151617181920212223String startTime = "2019-01-23";String endTime = "2019-04-12";String likeName = "%wzk5%";SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd");Date sT = simpleDateFormat.parse(startTime);Date eT = simpleDateFormat.parse(endTime);Specification&lt;SysUser&gt; sysUserSpecification = new Specification&lt;SysUser&gt;() &#123; @Override public Predicate toPredicate(Root&lt;SysUser&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder) &#123; Predicate sbirthday = criteriaBuilder.greaterThanOrEqualTo(root.get("birthday").as(Date.class),sT ); Predicate ebirthday = criteriaBuilder.lessThanOrEqualTo(root.get("birthday").as(Date.class), eT); Predicate sAnde = criteriaBuilder.and(sbirthday, ebirthday); // sAnde条件 = （ sbirthday条件 and ebirthday条件 ） Predicate like = criteriaBuilder.like(root.get("name").as(String.class), likeName); Predicate predicate = criteriaBuilder.or(sAnde, like); // predicate条件 = （ sAnde条件 or like条件 ） ==&gt; [（ sbirthday条件 and ebirthday条件 ）or like条件 ] return predicate; &#125;&#125;;List&lt;SysUser&gt; all = dao.findAll(sysUserSpecification);System.out.println("all的数目："+all.size());System.out.println("-----"); sql 1234567891011121314151617 -- 注意and or的位置 select sysuser0_.user_id as user_id1_1_, -- 省略一部分sql sysuser0_.version as version18_1_ from sys_user sysuser0_ where sysuser0_.birthday&gt;=? and sysuser0_.birthday&lt;=? or sysuser0_.name like ?/*参数值binding parameter [1] as [TIMESTAMP] - [Wed Jan 23 00:00:00 CST 2019]binding parameter [2] as [TIMESTAMP] - [Fri Apr 12 00:00:00 CST 2019]binding parameter [3] as [VARCHAR] - [%wzk5%]*/ 分页对象PageRequest PageRequest创建分页对象的静态方法 12PageRequest.of(int page, int size, Sort sort);PageRequest.of(int page, int size); 建议写一个分页对象工具类，前端传来参数处理快捷 12 方法命名规则查询 根据规则生成方法，不需要手动编写slq语句（建议使用IDEA编写，有提示不容易写错） 示例123456789@Repositorypublic interface MyUserDao extends JpaRepository&lt;SysUser,Long&gt;, JpaSpecificationExecutor&lt;SysUser&gt; &#123; List&lt;SysUser&gt; findFirst10ByNameLikeAndPhone(String name,String phone,Pageable pageable); // find：查询命令 // First10：获取前10条 // By：后面就是条件 // NameLike：name字段like sql：...where name like ？ // And：条件拼接 sql:...where 条件1 And 条件2 // Phone：phone字段 规则就是默认is sql:...where phone = ? 规则描述 按照Spring data 定义的规则，查询方法以find|read|get开头（比如 find、findBy、read、readBy、get、getBy），涉及条件查询时，条件的属性用条件关键字连接，要注意的是：条件属性首字母需大写。框架在进行方法名解析时，会先把方法名多余的前缀截取掉，然后对剩下部分进行解析。 如果方法的最后一个参数是 Sort 或者 Pageable 类型，也会提取相关的信息，以便按规则进行排序或者分页查询。 举例说明 比如 findByUserAddressZip()。框架在解析该方法时，首先剔除 findBy，然后对剩下的属性进行解析，详细规则如下（此处假设该方法针对的域对象为 AccountInfo 类型）： 1. 先判断 userAddressZip （根据 POJO 规范，首字母变为小写，下同）是否为 AccountInfo 的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，继续第二步； 2. 从右往左截取第一个大写字母开头的字符串（此处为 Zip），然后检查剩下的字符串是否为 AccountInfo 的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，则重复第二步，继续从右往左截取；最后假设 user 为 AccountInfo 的一个属性； 3. 接着处理剩下部分（ AddressZip ），先判断 user 所对应的类型是否有 addressZip 属性，如果有，则表示该方法最终是根据 “AccountInfo.user.addressZip” 的取值进行查询；否则继续按照步骤 2 的规则从右往左截取，最终表示根据”AccountInfo.user.address.zip” 的值进行查询。 可能会存在一种特殊情况，比如 AccountInfo 包含一个 user 的属性，也有一个 userAddress 属性，此时会存在混淆。读者可以明确在属性之间加上 ““ 以显式表达意图，比如 “findByUser_AddressZip()” 或者 “findByUserAddress_Zip()”。（强烈建议：无论是否存在混淆，都要在不同类层级之间加上”“ ，增加代码可读性） 一些情况当查询条件为null时 举例说明如下： 实体定义：对于一个客户实体Cus,包含有name和sex，均是String类型。 查询方法定义：List findByNameAndSex(String name,String sex); 使用时：dao.findByNameAndSex(null, “男”); 后台生成sql片断：where (cus0_.name is null) and cus0_.sex=? 结论：当查询时传值是null时，数据库中只有该字段是null的记录才符合条件，并不是说忽略这个条件。也就是说，这种查询方式，只适合于明确查询条件必须传的业务，对于动态查询（条件多少是动态的，例如一般的查询列表，由最终用户使用时决定输入那些查询条件），这种简单查询是不能满足要求的。 排序123List&lt;Cus&gt; findBySexOrderByName(String sex); //名称正序（正序时，推荐此方式，简单）List&lt;Cus&gt; findBySexOrderByNameAsc(String sex); //名称正序（效果同上）List&lt;Cus&gt; findBySexOrderByNameDesc(String sex); //名称倒序 结果限制1234567891011121314151617/** * 根据父ID，得到排序号最大的bo。 * 用于预计算新资源的排序号。 */Resource findFirstByFather_idOrderByOrderNumDesc(Long fatherId);User findFirstByOrderByLastnameAsc();User findTopByOrderByAgeDesc();Page&lt;User&gt; queryFirst10ByLastname(String lastname, Pageable pageable);Slice&lt;User&gt; findTop3ByLastname(String lastname, Pageable pageable);List&lt;User&gt; findFirst10ByLastname(String lastname, Sort sort);List&lt;User&gt; findTop10ByLastname(String lastname, Pageable pageable); 计数1Long countByLastname(String lastname); 删除12void deleteByProject_Id(Long id);void deleteByProject_Cus_id(Long id); 自定义sql查询单表查询123456789101112131415@Repositorypublic interface MyUserDao extends JpaRepository&lt;SysUser,Long&gt;, JpaSpecificationExecutor&lt;SysUser&gt; &#123; //SysUser findByNameAndPhone(String name,String phone); //List&lt;SysUser&gt; findFirst10ByNameLikeAndPhone(String name, String phone, Pageable pageable); //需要注解@Query，配置value的sql语句，nativeQuery = true @Query(value ="SELECT u.* FROM sys_user u where u.NAME = :userName ",nativeQuery = true) List&lt;SysUser&gt; selectUserAndRoleByUserId(@Param("userName")String userName); //如果方法的最后一个参数是 Sort 或者 Pageable 类型，也会提取相关的信息，以便按规则进行排序或者分页查询。 @Query(value = "SELECT * FROM sys_user where NAME = :userName ", nativeQuery = true, countQuery = "SELECT count(*) FROM sys_user where NAME = :userName") Page&lt;SysUser&gt; selectUserPage(@Param("userName")String userName,Pageable pageable);&#125; 多表查询 建议直接用Map接收结果集 原因：用实体类要添加字段，又要为字段配置对应的注解！配置繁琐并容易出错，没sql直观 1234@Query(value = "SELECT u.USER_ID ,r.NAME FROM sys_user u LEFT JOIN sys_role r on u.ROLE_ID = r.ROLE_ID where u.USER_ID = :userId ", nativeQuery = true, countQuery = "SELECT count(*) FROM sys_user u LEFT JOIN sys_role r on u.ROLE_ID = r.ROLE_ID where u.USER_ID = :userId ")List&lt;Map&gt; selectUserAndRoleByUserId(@Param("userId")String userId,Pageable pageable); jpa打印参数方法一:在配置文件配置 1logging.level.org.hibernate.type.descriptor.sql.BasicBinder=trace 方法二： 引入jar包 12345&lt;dependency&gt; &lt;groupId&gt;com.googlecode.log4jdbc&lt;/groupId&gt; &lt;artifactId&gt;log4jdbc&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 修改配置内容123456 //注意带#是原来的配置，不带#是方法二的配置#spring.datasource.url=jdbc:mysql://localhost:3306/guns?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8spring.datasource.url=jdbc:log4jdbc:mysql://localhost:3306/guns?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8#spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.driver-class-name=net.sf.log4jdbc.DriverSpy]]></content>
      <categories>
        <category>java</category>
        <category>框架</category>
        <category>jpa</category>
      </categories>
      <tags>
        <tag>jpa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chengzhi_shi_da_sha-bi]]></title>
    <url>%2F2019%2F06%2F19%2Fchengzhi-shi-da-sha-bi%2F</url>
    <content type="text"><![CDATA[生活真是操蛋]]></content>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf语法]]></title>
    <url>%2F2019%2F06%2F18%2FThymeleaf%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Thymeleaf3语法 文章目录结构 一. th属性1. 常用th属性解读html有的属性，Thymeleaf基本都有，而常用的属性大概有七八个。其中th属性执行的优先级从1~8，数字越低优先级越高 1. th:text 设置当前元素的文本内容，相同功能的还有th:utext，两者的区别在于前者不会转义html标签，后者会。优先级不高：order=7 HTML代码 123&lt;!--th:text 设置当前元素的文本内容，常用，优先级不高--&gt;&lt;p th:text="$&#123;thText&#125;" /&gt;&lt;p th:utext="$&#123;thUText&#125;" /&gt; 后台代码 123456@RequestMapping("thymeleaf")public String thymeleaf(ModelMap map) &#123; map.put("thText", "th:text 设置文本内容 &lt;b&gt;加粗&lt;/b&gt;"); map.put("thUText", "th:utext 设置文本内容 &lt;b&gt;加粗&lt;/b&gt;"); return "grammar/thymeleaf";&#125; 效果如下 12th:text 设置文本内容 &lt;b&gt;加粗&lt;/b&gt;th:utext 设置文本内容 加粗 2. th:value 设置当前元素的value值，类似修改指定属性的还有th:src，th:href。优先级不高：order=6 HTML代码 12&lt;!--th:value 设置当前元素的value值，常用，优先级仅比th:text高--&gt;&lt;input type="text" th:value="$&#123;thValue&#125;" /&gt; 后台代码 12345 @RequestMapping("/testThymeleaf")public String testThymeleaf(ModelMap map)&#123; map.put("thValue", "thValue 设置当前元素的value值"); return prefix+"/testThymeleaf";&#125; 效果如下 1thValue 设置当前元素的value值 3. th:each 遍历循环元素，和th:text或th:value一起使用。注意该属性修饰的标签位置，详细往后看。优先级很高：order=2 用法1 HTML代码 123456&lt;!--th:each 遍历列表，常用，优先级很高，仅此于代码块的插入--&gt;&lt;!--th:each 修饰在div上，则div层重复出现，若只想p标签遍历，则修饰在p标签上--&gt;&lt;div style="background: yellow" th:each="message : $&#123;thEach&#125;"&gt; &lt;!-- 遍历整个div-p，不推荐--&gt; &lt;p th:text="$&#123;message&#125;" /&gt;&lt;/div&gt; 后台代码 12345@RequestMapping("/testThymeleaf")public String testThymeleaf(ModelMap map)&#123; map.put("thEach", Arrays.asList("遍历列表1","遍历列表2","遍历列表3","遍历列表4")); return prefix+"/testThymeleaf";&#125; - 效果如下 ![查看不了，请留言](div-p一起遍历.jpg &quot;div-p都遍历&quot;) 用法二（常用,注意th:each标签的位置） HTML代码 1234&lt;div style="background: yellow"&gt; &lt;!--只遍历p，推荐使用--&gt; &lt;p th:text="$&#123;message&#125;" th:each="message : $&#123;thEach&#125;" /&gt;&lt;/div&gt; 后台代码 12345@RequestMapping("/testThymeleaf")public String testThymeleaf(ModelMap map)&#123; map.put("thEach", Arrays.asList("遍历列表1","遍历列表2","遍历列表3","遍历列表4")); return prefix+"/testThymeleaf";&#125; 效果 4. th:if 条件判断，类似的还有th:unless，th:switch，th:case。优先级较高：order=3 HTML代码 123&lt;!--th:if 条件判断，类似的有th:switch，th:case，优先级仅次于th:each, 其中#strings是变量表达式的内置方法--&gt;&lt;!--先判断th:if是否成立，，如果不成立就不显示整个P标签--&gt;&lt;p th:text="$&#123;thIf&#125;" th:if="$&#123;not #strings.isEmpty(thIf)&#125;"&gt;&lt;/p&gt; 后台代码 12345@RequestMapping("/testThymeleaf")public String testThymeleaf(ModelMap map)&#123; map.put("thIf", "我是有内容的"); return prefix+"/testThymeleaf";&#125; 效果如下 1我是有内容的 5. th:object 声明变量，一般和*{}一起配合使用，达到偷懒的效果。优先级一般：order=4 HTML代码 12345&lt;!--th:object 声明变量，和*&#123;&#125; 一起使用--&gt;&lt;div th:object="$&#123;thObject&#125;"&gt; &lt;p&gt;对象的id: &lt;span th:text="*&#123;id&#125;" /&gt;&lt;/p&gt;&lt;!--th:text="$&#123;thObject.id&#125;"--&gt; &lt;p&gt;对象的name: &lt;span th:text="*&#123;name&#125;" /&gt;&lt;/p&gt;&lt;!--$&#123;thObject.thName&#125;--&gt;&lt;/div&gt; 后台代码 12345678@RequestMapping("/testThymeleaf")public String testThymeleaf(ModelMap map)&#123; TestZk testZk = new TestZk(); testZk.setId(1L); testZk.setName("wzk"); map.put("thObject", testZk); return prefix+"/testThymeleaf";&#125; 效果如下 12对象的id: 1对象的name: wzk 二. 常用th属性使用 使用Thymeleaf属性需要注意点以下五点： 一、若要使用Thymeleaf语法，首先要声明名称空间： xmlns:th=”http://www.thymeleaf.org&quot; 二、设置文本内容 th:text，设置input的值 th:value，循环输出 th:each，条件判断 th:if，插入代码块 th:insert，定义代码块 th:fragment，声明变量 th:object 三、th:each 的用法需要格外注意，打个比方：如果你要循环一个div中的p标签，则th:each属性必须放在p标签上。若你将th:each属性放在div上，则循环的是将整个div。 四、变量表达式中提供了很多的内置方法，该内置方法是用#开头，请不要与#{}消息表达式弄混。 五、th:insert，th:replace，th:include 三种插入代码块的效果相似，但区别很大。 二、标准表达式语法123456789$&#123;...&#125; 变量表达式，Variable Expressions@&#123;...&#125; 链接表达式，Link URL Expressions#&#123;...&#125; 消息表达式，Message Expressions~&#123;...&#125; 代码块表达式，Fragment Expressions*&#123;...&#125; 选择变量表达式，Selection Variable Expressions 变量表达式使用频率最高，其功能也是非常的丰富。所以我们先从简单的代码块表达式开始，然后是消息表达式，再是链接表达式，最后是变量表达式，随带介绍选择变量表达式 1. ~{…} 代码块表达式 支持两种语法结构 123456推荐：~&#123;templatename::fragmentname&#125;支持：~&#123;templatename::#id&#125;templatename：模版名，Thymeleaf会根据模版名解析完整路径：/resources/templates/templatename.html，要注意文件的路径。fragmentname：片段名，Thymeleaf通过th:fragment声明定义代码块，即：th:fragment="fragmentname"id：HTML的id选择器，使用时要在前面加上#号，不支持class选择器。 代码块表达式的使用 代码块表达式需要配合th属性（th:insert，th:replace，th:include）一起使用。 th:insert：将代码块片段整个插入到使用了th:insert的HTML标签中， th:replace：将代码块片段整个替换使用了th:replace的HTML标签中， th:include：将代码块片段包含的内容插入到使用了th:include的HTML标签中， 用一个官方例子来区分三者的不同，第三部分会通过实战再次用到该知识。123456789101112131415161718192021222324&lt;!--th:fragment定义代码块标识--&gt;&lt;footer th:fragment="copy"&gt; 内容。。。。。&lt;/footer&gt;&lt;!--三种不同的引入方式--&gt;&lt;div th:insert="footer :: copy"&gt;&lt;/div&gt;&lt;div th:replace="footer :: copy"&gt;&lt;/div&gt;&lt;div th:include="footer :: copy"&gt;&lt;/div&gt;&lt;!--th:insert是在div中插入代码块，即多了一层div--&gt;&lt;div&gt; &lt;footer&gt; 内容。。。。。 &lt;/footer&gt;&lt;/div&gt;&lt;!--th:replace是将代码块代替当前div，其html结构和之前一致--&gt;&lt;footer&gt; 内容。。。。。&lt;/footer&gt;&lt;!--th:include是将代码块footer的内容插入到div中，即少了一层footer--&gt;&lt;div&gt; 内容。。。。。&lt;/div&gt; 3. #{…} 消息表达式 消息表达式一般用于国际化的场景。结构：th:text=”#{msg}” 。会在第三部分的实战详细介绍。 4. @{…} 链接表达式 链接表达式好处 1234567不管是静态资源的引用，form表单的请求，凡是链接都可以用@&#123;...&#125; 。这样可以动态获取项目路径，即便项目名变了，依然可以正常访问修改项目名，链接表达式会自动修改路径，避免资源文件找不到 (等价于 应用的访问路径)&lt;!--可以不加项目名称,直接用"/"--&gt;server.context-path = /项目名称 &lt;!--SpirngBoot2.0开启弃用了，改为使用一下参数设置--&gt;server.servlet.context-path = /项目名称//可以不填 链接表达式结构 无参：@{/xxx} 有参：@{/xxx(k1=v1,k2=v2)} 对应url结构：xxx?k1=v1&amp;k2=v2 引入本地资源：@{/项目本地的资源路径} 引入外部资源：@{/webjars/资源在jar包中的路径} 示例： 123 //使用ruoyi做例子&lt;script th:src="@&#123;/js/jquery.min.js&#125;"&gt;&lt;/script&gt; //在没有配置server.context-path的情况下 引用的文件是： 123456当设置server.servlet.context-path = / 请求的url为：http://localhost/js/jquery.min.js当设置server.servlet.context-path = /wzk 请求的url为：http://localhost/wzk/js/jquery.min.js//只是访问的路径改变了，后台引用文件的位置没变化 5. ${…}变量表达式变量表达式有丰富的内置方法，使其更强大，更方便。 变量表达式功能 一、可以获取对象的属性和方法 二、可以使用ctx，vars，locale，request，response，session，servletContext内置对象 三、可以使用dates，numbers，strings，objects，arrays，lists，sets，maps等内置方法（重点介绍） 常用的内置对象 一、ctx ：上下文对象。 二、vars ：上下文变量。 三、locale：上下文的语言环境。 四、request：（仅在web上下文）的 HttpServletRequest 对象。 五、response：（仅在web上下文）的 HttpServletResponse 对象。 六、session：（仅在web上下文）的 HttpSession 对象。 七、servletContext：（仅在web上下文）的 ServletContext 对象 内置对象使用示例123456&lt;p th:text="$&#123;#ctx.#servletContext.getContextPath()&#125;" /&gt;&lt;p th:text="$&#123;#vars.#servletContext.getContextPath()&#125;" /&gt;&lt;p th:text="$&#123;#request.getContextPath()&#125;" /&gt;&lt;p th:text="$&#123;#response.addHeader('headInfo','content')&#125;" /&gt;&lt;p th:text="$&#123;#session.getAttribute('mySession')&#125;" /&gt;&lt;p th:text="$&#123;#servletContext.getContextPath()&#125;" /&gt; 常用的内置方法 一、strings：字符串格式化方法，常用的Java方法它都有。比如：equals，equalsIgnoreCase，length，trim，toUpperCase，toLowerCase，indexOf，substring，replace，startsWith，endsWith，contains，containsIgnoreCase等 二、numbers：数值格式化方法，常用的方法有：formatDecimal等 三、bools：布尔方法，常用的方法有：isTrue，isFalse等 四、arrays：数组方法，常用的方法有：toArray，length，isEmpty，contains，containsAll等 五、lists，sets：集合方法，常用的方法有：toList，size，isEmpty，contains，containsAll，sort等 六、maps：对象方法，常用的方法有：size，isEmpty，containsKey，containsValue等 七、dates：日期方法，常用的方法有：format，year，month，hour，createNow等 常用内置方法示例 前端代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 &lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;ITDragon Thymeleaf 内置方法&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;ITDragon Thymeleaf 内置方法&lt;/h2&gt; &lt;h3&gt;#strings &lt;/h3&gt; &lt;div th:if="$&#123;not #strings.isEmpty(itdragonStr)&#125;" &gt; &lt;p&gt;Old Str : &lt;span th:text="$&#123;itdragonStr&#125;"/&gt;&lt;/p&gt; &lt;p&gt;toUpperCase : &lt;span th:text="$&#123;#strings.toUpperCase(itdragonStr)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;toLowerCase : &lt;span th:text="$&#123;#strings.toLowerCase(itdragonStr)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;equals : &lt;span th:text="$&#123;#strings.equals(itdragonStr, 'itdragonblog')&#125;"/&gt;&lt;/p&gt; &lt;p&gt;equalsIgnoreCase : &lt;span th:text="$&#123;#strings.equalsIgnoreCase(itdragonStr, 'itdragonblog')&#125;"/&gt;&lt;/p&gt; &lt;p&gt;indexOf : &lt;span th:text="$&#123;#strings.indexOf(itdragonStr, 'r')&#125;"/&gt;&lt;/p&gt; &lt;p&gt;substring : &lt;span th:text="$&#123;#strings.substring(itdragonStr, 2, 8)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;replace : &lt;span th:text="$&#123;#strings.replace(itdragonStr, 'it', 'IT')&#125;"/&gt;&lt;/p&gt; &lt;p&gt;startsWith : &lt;span th:text="$&#123;#strings.startsWith(itdragonStr, 'it')&#125;"/&gt;&lt;/p&gt; &lt;p&gt;contains : &lt;span th:text="$&#123;#strings.contains(itdragonStr, 'IT')&#125;"/&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#numbers &lt;/h3&gt; &lt;div&gt; &lt;p&gt;formatDecimal 整数部分随意，小数点后保留两位，四舍五入: &lt;span th:text="$&#123;#numbers.formatDecimal(itdragonNum, 0, 2)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;formatDecimal 整数部分保留五位数，小数点后保留两位，四舍五入: &lt;span th:text="$&#123;#numbers.formatDecimal(itdragonNum, 5, 2)&#125;"/&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#bools &lt;/h3&gt; &lt;div th:if="$&#123;#bools.isTrue(itdragonBool)&#125;"&gt; &lt;p th:text="$&#123;itdragonBool&#125;"&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#arrays &lt;/h3&gt; &lt;div th:if="$&#123;not #arrays.isEmpty(itdragonArray)&#125;"&gt; &lt;p&gt;length : &lt;span th:text="$&#123;#arrays.length(itdragonArray)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;contains : &lt;span th:text="$&#123;#arrays.contains(itdragonArray, 5)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;containsAll : &lt;span th:text="$&#123;#arrays.containsAll(itdragonArray, itdragonArray)&#125;"/&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#lists &lt;/h3&gt; &lt;div th:if="$&#123;not #lists.isEmpty(itdragonList)&#125;"&gt; &lt;p&gt;size : &lt;span th:text="$&#123;#lists.size(itdragonList)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;contains : &lt;span th:text="$&#123;#lists.contains(itdragonList, 0)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;sort : &lt;span th:text="$&#123;#lists.sort(itdragonList)&#125;"/&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#maps &lt;/h3&gt; &lt;div th:if="$&#123;not #maps.isEmpty(itdragonMap)&#125;"&gt; &lt;p&gt;size : &lt;span th:text="$&#123;#maps.size(itdragonMap)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;containsKey : &lt;span th:text="$&#123;#maps.containsKey(itdragonMap, 'thName')&#125;"/&gt;&lt;/p&gt; &lt;p&gt;containsValue : &lt;span th:text="$&#123;#maps.containsValue(itdragonMap, '#maps')&#125;"/&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#dates &lt;/h3&gt; &lt;div&gt; &lt;p&gt;format : &lt;span th:text="$&#123;#dates.format(itdragonDate)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;custom format : &lt;span th:text="$&#123;#dates.format(itdragonDate, 'yyyy-MM-dd HH:mm:ss')&#125;"/&gt;&lt;/p&gt; &lt;p&gt;day : &lt;span th:text="$&#123;#dates.day(itdragonDate)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;month : &lt;span th:text="$&#123;#dates.month(itdragonDate)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;monthName : &lt;span th:text="$&#123;#dates.monthName(itdragonDate)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;year : &lt;span th:text="$&#123;#dates.year(itdragonDate)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;dayOfWeekName : &lt;span th:text="$&#123;#dates.dayOfWeekName(itdragonDate)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;hour : &lt;span th:text="$&#123;#dates.hour(itdragonDate)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;minute : &lt;span th:text="$&#123;#dates.minute(itdragonDate)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;second : &lt;span th:text="$&#123;#dates.second(itdragonDate)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;createNow : &lt;span th:text="$&#123;#dates.createNow()&#125;"/&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 后端代码 1234567891011121314@RequestMapping("varexpressions")public String varexpressions(ModelMap map) &#123; map.put("itdragonStr", "itdragonBlog"); map.put("itdragonBool", true); map.put("itdragonArray", new Integer[]&#123;1,2,3,4&#125;); map.put("itdragonList", Arrays.asList(1,3,2,4,0)); Map itdragonMap = new HashMap(); itdragonMap.put("thName", "$&#123;#...&#125;"); itdragonMap.put("desc", "变量表达式内置方法"); map.put("itdragonMap", itdragonMap); map.put("itdragonDate", new Date()); map.put("itdragonNum", 888.888D); return "grammar/varexpressions";&#125; 三. Thymeleaf在SpringBoot应用Thymeleaf是Spring Boot 官方推荐使用的模版引擎，这也意味着用Thymeleaf比其他模版引擎更简单。开发步骤：第一步：引入Thymeleaf依赖。第二步： 提取公共页面，提高代码的重用性，统一页面风格。第三步：页面显示和国际化功能 引入Thymeleafpom.xml 引入Thymeleaf的依赖，并确定其版本12345&lt;!--引入模版引擎thymeleaf--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 四、总结一、Thymeleaf 是Spring Boot 官方推荐的Java模版引擎框架，其文件扩展名为.html 二、Thymeleaf 几乎支持所有的html属性，用于赋值的th:text和th:value，用于循环遍历的th:each，用于条件判断的th:if 三、Thymeleaf 提供四种标准的表达式，有丰富内置方法的${}，用于国际化的#{}，用于代码插入的~{}，用于处理链接的@{} 四、一定要注意循环遍历的th:each和代码插入的th:insert用法，尽量避免破坏html结构的细节问题 参考文章 https://www.cnblogs.com/itdragon/archive/2018/04/13/8724291.html]]></content>
      <categories>
        <category>模板引擎</category>
        <category>Thymeleaf</category>
      </categories>
      <tags>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[若依时间表单]]></title>
    <url>%2F2019%2F06%2F18%2F%E8%8B%A5%E4%BE%9D%E6%97%B6%E9%97%B4%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[若依新增一个日期选择表单一. datetimepicker示例 引入js，css文件 123//由于common.js里面没有引进来的&lt;th:block th:include="include :: datetimepicker-js" /&gt;&lt;th:block th:include="include :: datetimepicker-css" /&gt; 初始化时间控件 12345678910111213141516171819//日期选择表单代码&lt;div class="form-group"&gt; &lt;label class="font-noraml"&gt;显示年月日&lt;/label&gt; &lt;div class="input-group date"&gt; &lt;span class="input-group-addon"&gt; &lt;i class="fa fa-calendar"&gt;&lt;/i&gt; &lt;/span&gt; &lt;input type="text" class="form-control" id="需要初始化的ID"&gt; &lt;/div&gt;&lt;/div&gt; //初始化时间插件$（function（）&#123; $("#需要初始化的ID").datetimepicker(&#123; format: "yyyy-mm-dd", minView: "month", autoclose: true &#125;);&#125;） 二. laydate示例 初始化控件12345678910111213141516171819//日期选择表单代码&lt;div class="form-group"&gt; &lt;label class="font-noraml"&gt;显示年月日&lt;/label&gt; &lt;div class="input-group date"&gt; &lt;span class="input-group-addon"&gt;&lt;i class="fa fa-calendar"&gt;&lt;/i&gt;&lt;/span&gt; &lt;input type="text" class="form-control" id="需要初始化的ID" &gt; &lt;/div&gt;&lt;/div&gt;//common.js里面已经有了laydate所需的js，css文件$(function()&#123; layui.use('laydate', function()&#123; var laydate = layui.laydate; laydate.render(&#123; elem: '#需要初始化的ID', type: 'date' &#125;);&#125;);&#125;) 新增一个单框范围选择一. laydate示例 前端代码 123456&lt;li class="select-time"&gt; &lt;label&gt;创建时间： &lt;/label&gt; &lt;input type="text" class="time-input" id="createTimeBeginTime" placeholder="开始时间" name="params[createTimeBeginTime]"/&gt; &lt;span&gt;-&lt;/span&gt; &lt;input type="text" class="time-input" id="createTimeBeginTimeEndTime" placeholder="结束时间" name="params[createTimeBeginTimeEndTime]"/&gt;&lt;/li&gt; 后台处理Mapper 1234567//实体类继承了BaseEntity类，BaseEntity里面名称为params的Map，用来存放其他参数的&lt;if test="params.birthdayBeginTime != null and params.birthdayBeginTime != ''"&gt;&lt;!-- 开始时间检索 --&gt;and date_format(birthday,'%y%m%d') &amp;gt;= date_format(#&#123;params.birthdayBeginTime&#125;,'%y%m%d')&lt;/if&gt;&lt;if test="params.birthdayEndTime != null and params.birthdayEndTime != ''"&gt;&lt;!-- 结束时间检索 --&gt;and date_format(birthday,'%y%m%d') &amp;lt;= date_format(#&#123;params.birthdayEndTime&#125;,'%y%m%d')&lt;/if&gt;]]></content>
      <tags>
        <tag>ruoyi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown基本语法]]></title>
    <url>%2F2019%2F06%2F17%2Fmarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 标题示例 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 2. 字体 加粗示例：1**加粗的字体** 效果效果如下： 加粗的字体 斜体示例： 1*斜体的字体* 效果效果如下： 加粗的字体 斜体加粗示例： 1***斜体加粗*** 效果如下： 斜体加粗 删除线示例：1~~带有删除线的字体~~ 效果如下： 带有删除线的字体 3. 引用示例： 1&gt;这是引用的内容 效果如下： 这是引用的内容 4. 分割线示例： 123ps:使用时要去掉////***//--- 效果如下： 5. 图片语法 1234![图片alt](图片地址 ''图片title'')图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 1![无法显示请M我](https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2426942089,1305444686&amp;fm=26&amp;gp=0.jpg "搬砖使我快乐") 效果如下： 6. 列表 无序列表示例：1234567- 列表1 - 子列表1 - 子类表2 - 子子列表1 - 子子列表2- 列表2- 列表3 效果如下： 列表1 子列表1 子类表2 子子列表1 子子列表2 列表2 列表3 有序列表示例：1231.有序列表12.有序列表23.有序列表3 效果如下：1.有序列表12.有序列表23.有序列表3 7.表格语法： 12345678910|表头|表头|表头||---|:--:|---:|内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右 示例： 12345|姓名|技能|排行||--|:--:|--:|张三|剑|大哥李四|斧|二哥王五|枪|三弟 效果如下： 姓名 技能 排行 张三 剑 大哥 李四 斧 二哥 王五 枪 三弟 8.代码语法： 单行代码：代码之间分别用一个反引号包起来示例： 1`&lt;html&gt;&lt;/html&gt;` 效果如下： &lt;html&gt;&lt;/html&gt; 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行示例： 12345ps:实际使用请去掉[][```] &lt;html&gt;&lt;/html&gt; &lt;html&gt;&lt;/html&gt;[```] 效果如下： 12&lt;html&gt;&lt;/html&gt;&lt;html&gt;&lt;/html&gt; 9.超链接跳转语法： 1[文字内容](网址) 示例： 1[百度一下]（www.baidu.com） 效果如下百度一下]]></content>
      <categories>
        <category>Markdown</category>
        <category>基本使用</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
